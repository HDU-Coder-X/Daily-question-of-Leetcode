# [589. N 叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)

# 题目描述：

给定一个 n 叉树的根节点  `root` ，返回 *其节点值的 **前序遍历*** 。

n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 `null` 分隔（请参见示例）。



**示例 1:**

![](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)

```
输入：root = [1,null,3,2,4,null,5,6]
输出：[1,3,5,6,2,4]
```

**示例 2:**

![](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)

```
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]
```




# 解答：

## C++：

```cpp

```

## JavaScript：

递归：

```JavaScript
const preorder = root => {
  const res = [];
  const dfs = root => {
    if (!root) return;
    res.push(root.val);
    root.children.forEach(item => {
      dfs(item);
    });
  };

  dfs(root);
  return res;
};
```

迭代：

```javascript
const preorder = root => {
  if (!root) return [];
  const res = [];
  const stack = [root];

  while (stack.length) {
    const node = stack.pop();
    res.push(node.val);
    let len = node.children.length;
    while (len) {
      stack.push(node.children[len - 1]);
      len--;
    }
  }

  return res;
};
```

## C：

```c

```

## Java：

```java
class Solution {

    private List<Integer> ans = new ArrayList<>();

    private void dfs(Node root){
        if(root == null) return;
        ans.add(root.val);
        for(Node child : root.children){
            dfs(child);
        }

    }

    public List<Integer> preorder(Node root) {
        dfs(root);
        return ans;
    }
}
```

## Python：

```python

```

